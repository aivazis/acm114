% -*- LaTeX -*-
% -*- coding: utf-8 -*-
%
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%
%                             michael a.g. aïvázis
%                      california institute of technology
%                      (c) 1998-2010  all rights reserved
%
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

\lecture{Overview of algorithms}{20100106}

% --------------------------------------
% the INSERTION-SORT algorithm
\begin{frame}[fragile]
%
  \frametitle{A sorting algorithm}
%
    \begin{center}
      \begin{minipage}{.75\linewidth}
        \begin{algorithm}[H]
          \label{alg:insertion-sort}
%
          \dontprintsemicolon
          %\nocaptionofalgo
          \setalcaphskip{0ex}
%
          \caption{\insertionsort($S$)}
          \vspace{.5em}
%
          \For{$j \leftarrow 2$  \KwTo length[S]}{
            $key \leftarrow S[j]$ \;
            $i \leftarrow j-1$ \;
            \While{$i > 0$ \KwAnd $S[i] > key$}{
              $S[i+1] \leftarrow S[i]$ \;
              $i \leftarrow i-1$ \;
            }
            $S[i+1] \leftarrow key$
          }
%
          \vspace{.5em}
%
        \end{algorithm}
      \end{minipage}
    \end{center}
%
  \begin{itemize}
%
  \item valid inputs:
    \begin{itemize}
    \item empty sequence, singlet, other sequences of finite length
    \item what kinds of objects in $S$?
    \end{itemize}
%
  \item walk through it by hand with $S = (5, 2, 4, 6, 1, 3)$
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% pseudocode
\begin{frame}[fragile]
%
  \frametitle{Pseudocode conventions}
%
  \begin{itemize}
  \item the symbol ``$\triangleright$'' indicates a comment through to the end of the line
  \item block structure is indicated by the indentation level
  \item all variables are local; no global variables, unless explicitly marked
  \item $i \leftarrow j \leftarrow k$ assigns the rightmost expression to all the other
    variables
  \item indexing: $S[i]$; slicing: $S[i .. j]$
  \item conditionals, looping constructs, function calls should be familiar
  \item compound objects have attributes or fields that are referenced using indexing,
    e.g. $length[S]$
  \item variables assigned to objects or containers are references
  \item parameters passed to procedures {\em by assignment}
  \end{itemize}
%
\end{frame}
        
% --------------------------------------
% python implementation of insertion-sort
\begin{frame}[fragile]
%
  \frametitle{Python implementation}
%
  \begin{itemize}
%
  \item direct translation of pseudocode in python, with no attempt to improve
%
  \begin{center}
    \begin{minipage}[h]{.75\linewidth}
      \begin{python}[%
        label={lst:insertion-sort:python},
        caption={Python implementation of insertion\_sort}
]
%
def insertion_sort(A):
    for j in range(1, len(A)):
        key = A[j]
        i = j-1
        while i>=0 and A[i]>key:
            A[i+1] = A[i]
            i = i-1
        A[i+1] = key
      \end{python}
    \end{minipage}
  \end{center}
%
  \item only minor adjustments to loop indices since python lists are zero based
  \end{itemize}
%
\end{frame}

% --------------------------------------
% algorithm analysis
\begin{frame}[fragile]
%
  \frametitle{Analyzing algorithms}
%
  \begin{itemize}
%
  \item algorithm analysis is the computation of resource requirements
    \begin{itemize}
      \item memory, communication bandwidth, {\em computational time}
    \end{itemize}
%
  \item need a model for the implementation environment
    \begin{itemize}
      \item RAM: {\em random access machine}
      \item an abstraction of a single processor sequential execution machine that has access
        to a single block of memory with uniform access cost
      \item even though the model is extermely simple, algorithm analysis remains a hard
        problem, full of subtleties
    \end{itemize}
%
    \item in general, we seek to relate the running time to input size
      \begin{itemize}
        \item definition of input size is problem dependent -- could be number of items to sort,
          or number of grid points in a mesh, etc.
        \item running time counts the number of primitive steps executed
        \item different lines have different costs
        \item but each execution of a given line is assumed to cost the same
      \end{itemize}
%
    \item exercise: decorate \algref{insertion-sort} with the number of times each line is
      executed
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% algorithm design strategies
\begin{frame}[fragile]
%
  \frametitle{Designing algorithms}
%
  \begin{itemize}
%
  \item \insertionsort\ is {\em incremental}:
    \begin{itemize}
      \item having sorted $A[i..j]$, put $A[j]$ in its proper place
      \item how would you break this up into tasks that can be executed in parallel?
    \end{itemize}
%
  \item one alternative is {\em divide-and-conquer}: \mergesort
    \begin{itemize}
      \item {\em divide}: split $A$ into two parts of roughly equal length
      \item {\em conquer}: sort the subsequences recursively
      \item {\em combine}: merge the two sorted subsequences to produce the sorted output
    \end{itemize}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% merge sort
\begin{frame}[fragile]
%
  \frametitle{Sorting by divide-and-conquer}
%
    \begin{center}
      \begin{minipage}{.75\linewidth}
        \begin{algorithm}[H]
          \label{alg:merge-sort}
%
          \dontprintsemicolon
          %\nocaptionofalgo
          \setalcaphskip{0ex}
%
          \caption{\mergesort($S$, $p$, $r$)}
          \vspace{.5em}
%
          \If{$p < r$}{
            $q \leftarrow \lfloor (p+r)/2 \rfloor$ \;
            \mergesort($S$, $p$, $q$) \;
            \mergesort($S$, $q+1$, $r$) \;
            \merge($S$, $p$, $q$, $r$) \;
          }
%
          \vspace{.5em}
%
        \end{algorithm}
      \end{minipage}
    \end{center}
%
  \begin{itemize}
%
  \item {\em exercise}: write \merge; can be done in $\Theta(r-p+1)$
%
  \item analysis of running time:
    \begin{itemize}
    \item involves solving a recurrence relation
    \item worst case:
      \[
      T(n) = \left\{
      \begin{array}{ll}
        \Theta(1)         & {\rm if\ } n = 1 \\
        2T(n/2)+\Theta(n) & {\rm if\ } n > 1
      \end{array} \right\}
      \rightarrow \Theta(n \log n)
      \]
    \end{itemize}
%
  \item is this a better candidate for parallel sorting?
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% motivation for parallel computing
\begin{frame}[fragile]
%
  \frametitle{Motivations for going parallel}
%
  \begin{itemize}
%
  \item why bother?
    \begin{itemize}
    \item {\em speed}: there are fundamental limits to the processing power of a single processor
    \item {\em throughput}: time to solution is critical for many problems
    \item {\em size}: high resolution requires lots of memory
    \item {\em availability}: the tool exists, use it
    \end{itemize}
%
  \item but, be careful
    \begin{itemize}
    \item the commercial market is unstable
    \item the computing environment is somewhat primitive
    \item software packages and libraries are emerging slowly
    \item parallel programming is not hard, but it requires {\em discipline}
    \end{itemize}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% template
\begin{frame}[fragile]
%
  \frametitle{Taxonomy}
%
  \begin{itemize}
%
  \item an early classification of computer systems focused on the relation between {\em
    instruction streams} and {\em data streams}:
    \begin{itemize}
      \item SISD: single instruction, single data
      \item: SIMD: single instruction, multiple data
      \item: MIMD: multiple instruction, multiple data
    \end{itemize}
%
    \item SISD describes conventional serial computers
    \begin{itemize}
      \item the programming model; the hardware has moved on...
    \end{itemize}
%
    \item SIMD and MIMD are the traditional models for parallel machines
%
    \item MIMD systems are often programmed in SPMD mode: single {\em program}, multiple data
  \end{itemize}
%
\end{frame}

% --------------------------------------
% template
\begin{frame}[fragile]
%
  \frametitle{Architectural issues}
%
  \begin{itemize}
%
  \item {\em control:} SIMD vs.~MIMD
  \item {\em co\"ordination}: synchronous vs.~asynchronous
  \item {\em memory organization}: private vs.~shared
  \item {\em address space}: local vs.~global
  \item {\em memory access}: uniform vs.~ non-uniform
  \item {\em granularity}: the power of each processor
  \item {\em scalability}: dependence on the number of processors
  \item {\em interconnect}: topology, routing, switching
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% template
\begin{frame}[fragile]
%
  \frametitle{Tradeoffs}
%
  \begin{center}
    \begin{minipage}{.75\linewidth}
      \begin{tabular}{l|l|l}
                        & shared memory & distributed memory \\ \hline
        scalability     & {\em harder}  & {\em easier} \\
        programmability & {\em easier}  & {\em harder}
      \end{tabular}
    \end{minipage}
  \end{center}

%
  \begin{itemize}
%
  \item shared memory permits parallelizing serial program gradually, focusing on worst
    bottlenecks first
%
  \item distributed memory requires partitioning and distributing both data and work across
    processors, which usually rules out incremental parallelization
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% template
\begin{frame}[fragile]
%
  \frametitle{Blank}
%
  \begin{itemize}
%
  \item a point
%
  \end{itemize}
%
\end{frame}

% end of file 
