% -*- LaTeX -*-
% -*- coding: utf-8 -*-
%
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%
%                             michael a.g. aïvázis
%                      california institute of technology
%                      (c) 1998-2010  all rights reserved
%
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

\lecture{Overview of algorithms}{20100106}

% --------------------------------------
% the INSERTION-SORT algorithm
\begin{frame}[fragile]
%
  \frametitle{A sorting algorithm}
%
    \begin{center}
      \begin{minipage}{.75\linewidth}
        \begin{algorithm}[H]
          \label{alg:insertion-sort}
%
          \dontprintsemicolon
          %\nocaptionofalgo
          \setalcaphskip{0ex}
%
          \caption{\insertionsort($S$)}
          \vspace{.5em}
%
          \For{$j \leftarrow 2$  \KwTo length[S]}{
            $key \leftarrow S[j]$ \;
            $i \leftarrow j-1$ \;
            \While{$i > 0$ \KwAnd $S[i] > key$}{
              $S[i+1] \leftarrow S[i]$ \;
              $i \leftarrow i-1$ \;
            }
            $S[i+1] \leftarrow key$
          }
%
          \vspace{.5em}
%
        \end{algorithm}
      \end{minipage}
    \end{center}
%
  \begin{itemize}
%
  \item valid inputs:
    \begin{itemize}
    \item empty sequence, singlet, other sequences of finite length
    \item what kinds of objects in $S$?
    \end{itemize}
%
  \item walk through it by hand with $S = (5, 2, 4, 6, 1, 3)$
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% pseudocode
\begin{frame}[fragile]
%
  \frametitle{Pseudocode conventions}
%
  \begin{itemize}
  \item the symbol ``$\triangleright$'' indicates a comment through to the end of the line
  \item block structure is indicated by the indentation level
  \item all variables are local; no global variables, unless explicitly marked
  \item $i \leftarrow j \leftarrow k$ assigns the rightmost expression to all the other
    variables
  \item indexing: $S[i]$; slicing: $S[i .. j]$
  \item conditionals, looping constructs, function calls should be familiar
  \item compound objects have attributes or fields that are referenced using indexing,
    e.g. $length[S]$
  \item variables assigned to objects or containers are references
  \item parameters passed to procedures {\em by assignment}
  \end{itemize}
%
\end{frame}
        
% --------------------------------------
% python implementation of insertion-sort
\begin{frame}[fragile]
%
  \frametitle{Python implementation}
%
  \begin{itemize}
%
  \item direct translation of pseudocode in python, with no attempt to improve
%
  \begin{center}
    \begin{minipage}[h]{.75\linewidth}
      \begin{python}[%
        label={lst:insertion-sort:python},
        caption={Python implementation of insertion\_sort}
]
%
def insertion_sort(A):
    for j in range(1, len(A)):
        key = A[j]
        i = j-1
        while i>=0 and A[i]>key:
            A[i+1] = A[i]
            i = i-1
        A[i+1] = key
      \end{python}
    \end{minipage}
  \end{center}
%
  \item only minor adjustments to loop indices since python lists are zero based
  \end{itemize}
%
\end{frame}

% --------------------------------------
% algorithm analysis
\begin{frame}[fragile]
%
  \frametitle{Analyzing algorithms}
%
  \begin{itemize}
%
  \item algorithm analysis is the computation of resource requirements
    \begin{itemize}
      \item memory, communication bandwidth, {\em computational time}
    \end{itemize}
%
  \item need a model for the implementation environment
    \begin{itemize}
      \item RAM: {\em random access machine}
      \item an abstraction of a single processor sequential execution machine that has access
        to a single block of memory with uniform access cost
      \item even though the model is extermely simple, algorithm analysis remains a hard
        problem, full of subtleties
    \end{itemize}
%
    \item in general, we seek to relate the running time to input size
      \begin{itemize}
        \item definition of input size is problem dependent -- could be number of items to sort,
          or number of grid points in a mesh, etc.
        \item running time counts the number of primitive steps executed
        \item different lines have different costs
        \item but each execution of a given line is assumed to cost the same
      \end{itemize}
%
    \item exercise: decorate \algref{insertion-sort} with the number of times each line is
      executed
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% algorithm design strategies
\begin{frame}[fragile]
%
  \frametitle{Designing algorithms}
%
  \begin{itemize}
%
  \item \insertionsort\ is {\em incremental}:
    \begin{itemize}
      \item having sorted $A[i..j]$, put $A[j]$ in its proper place
      \item how would you break this up into tasks that can be executed in parallel?
    \end{itemize}
%
  \item one alternative is {\em divide-and-conquer}: \mergesort
    \begin{itemize}
      \item {\em divide}: split $A$ into two parts of roughly equal length
      \item {\em conquer}: sort the subsequences recursively
      \item {\em combine}: merge the two sorted subsequences to produce the sorted output
    \end{itemize}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% merge sort
\begin{frame}[fragile]
%
  \frametitle{Sorting by divide-and-conquer}
%
    \begin{center}
      \begin{minipage}{.75\linewidth}
        \begin{algorithm}[H]
          \label{alg:merge-sort}
%
          \dontprintsemicolon
          %\nocaptionofalgo
          \setalcaphskip{0ex}
%
          \caption{\mergesort($S$, $p$, $r$)}
          \vspace{.5em}
%
          \If{$p < r$}{
            $q \leftarrow \lfloor (p+r)/2 \rfloor$ \;
            \mergesort($S$, $p$, $q$) \;
            \mergesort($S$, $q+1$, $r$) \;
            \merge($S$, $p$, $q$, $r$) \;
          }
%
          \vspace{.5em}
%
        \end{algorithm}
      \end{minipage}
    \end{center}
%
  \begin{itemize}
%
  \item {\em exercise}: write \merge; can be done in $\Theta(r-p+1)$
%
  \item analysis of running time:
    \begin{itemize}
    \item involves solving a recurrence relation
    \item worst case:
      \[
      T(n) = \left\{
      \begin{array}{ll}
        \Theta(1)         & {\rm if\ } n = 1 \\
        2T(n/2)+\Theta(n) & {\rm if\ } n > 1
      \end{array} \right\}
      \rightarrow \Theta(n \log n)
      \]
    \end{itemize}
%
  \item is this a better candidate for parallel sorting?
%
  \end{itemize}
%
\end{frame}

% end of file 
